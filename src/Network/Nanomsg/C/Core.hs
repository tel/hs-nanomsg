-- Copyright 2013 Joseph Tel Abrahamson
--
-- Licensed under the Apache License, Version 2.0 (the "License"); you
-- may not use this file except in compliance with the License. You
-- may obtain a copy of the License at
-- 
--   http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-- implied. See the License for the specific language governing
-- permissions and limitations under the License.

-- |
-- Module      : Network.Nanomsg.C.Core
-- Copyright   : (c) Joseph Abrahamson 2013
-- License     : Apache 2.0
-- 
-- Maintainer  : me@jspha.com
-- Stability   : experimental
-- Portability : non-portable

{-# LANGUAGE GeneralizedNewtypeDeriving, RankNTypes #-}
module Network.Nanomsg.C.Core (

  -- * Basic API

  -- These are the primary functions for interacting with Nanomsg. The
  -- majority of the types exported from this module are used to work
  -- with these functions in a typesafe manner.

  Socket (..), Endpoint (..), new
  
  -- Socket, Endpoint,
  -- newSocket, new, raw, close,
  -- setOpt,
  -- bind, connect, shutdown,

  ) where

import Control.Exception

import Foreign (Storable)
import Foreign.C.Types
import Foreign.C.String
import System.Posix.Types

import GHC.IO.Exception

import qualified Data.ByteString.Char8 as S8
import qualified Data.ByteString as S

import Network.Nanomsg.C.Protocols
import Network.Nanomsg.C.Domains
import Network.Nanomsg.C.Address
import Network.Nanomsg.C.Errors

-- | Sockets are just wrappers over file handles. They have two
-- phantom type variables, the first of which ensures that sockets are
-- used in single-threaded environments the second indicates what kind
-- of scalability protocol the socket is attuned to.
newtype Socket s p = Socket Fd deriving (Eq, Storable)

instance Show (Socket s Pair)       where show _ = "Socket{Pair}"
instance Show (Socket s Req)        where show _ = "Socket{Req}"
instance Show (Socket s Rep)        where show _ = "Socket{Rep}"
instance Show (Socket s Pub)        where show _ = "Socket{Pub}"
instance Show (Socket s Sub)        where show _ = "Socket{Sub}"
instance Show (Socket s Surveyor)   where show _ = "Socket{Surveyor}"
instance Show (Socket s Respondent) where show _ = "Socket{Respondent}"
instance Show (Socket s Source)     where show _ = "Socket{Source}"
instance Show (Socket s Sink)       where show _ = "Socket{Sink}"
instance Show (Socket s Push)       where show _ = "Socket{Push}"
instance Show (Socket s Pull)       where show _ = "Socket{Pull}"


-- | Endpoint IDs are generated by 'bind' and 'connect' and handed to
-- 'shutdown' to terminate them. Endpoint IDs are *socket-local*---it
-- is not (necessarily) an error but semantically nonsensical to hand
-- an endpoint from one socket to some different socket. To ensure
-- this, they have a phantom type variable which must match that of
-- the socket.
data Endpoint s = Endpoint
                  CInt         -- ^ The endpoint identifier
                  S.ByteString -- ^ The address it was bound on

instance Eq (Endpoint s) where
  Endpoint a _ == Endpoint b _ = a == b

instance Show (Endpoint s) where
  show (Endpoint _ addy) = "Endpoint{" ++ S8.unpack addy ++ "}"

-- | Runs a continuation giving it a fresh socket of the desired
-- kind. Ensures that socket endpoints are local to a particular
-- socket and that the socket is properly closed. Can throw exceptions
-- when system-level problems are encountered.
new :: Protocol p => Domain -> p -> (forall s. Socket s p -> IO r) -> IO r
new domain protocol k = do
  sockInt <- nn_socket domain (proValue protocol)
  case sockInt of

    -- Socket creation failed.
    --
    -- The possible reasons for this failure are the following:
    --
    -- EAFNOSUPPORT "Specified address family is not supported."
    -- Impossible --- types ensure that only valid families are used
    -- 
    -- EINVAL "Unknown protocol."  Impossible --- types ensure that
    -- only valid families are used
    -- 
    -- EMFILE "The limit on the total number of open SP sockets or OS
    -- limit for file descriptors has been reached." Major failure ---
    -- there's no reasonable way for this local thread to handle this
    -- error.
    -- 
    -- ETERM "The library is terminating." Major failure --- there's
    -- no reasonable way for this local thread to handle this error.
    --
    -- So, all of the errors are either impossible or hair-on-fire
    -- problematic, so we'll let these exceptions rise.
    n | n < 0 -> do
      errno <- nnGetErrno
      case errno of
        e | e == eMFILE ->
          ioError $ IOError
            { ioe_handle      = Nothing
            , ioe_type        = ResourceExhausted
            , ioe_location    = "Network.Nanomsg.C.Core.withNew"
            , ioe_description = show e
            , ioe_errno       = Just (errnoInt e)
            , ioe_filename    = Nothing
            }
          | e == eTERM ->
          ioError $ IOError
            { ioe_handle      = Nothing
            , ioe_type        = IllegalOperation
            , ioe_location    = "Network.Nanomsg.C.Core.withNew"
            , ioe_description = show e
            , ioe_errno       = Just (errnoInt e)
            , ioe_filename    = Nothing
            }
          | otherwise ->
              error "Network.Nanomsg.C.Core.withNew \"impossible\" error"

      | otherwise -> do

      let sock = Socket (Fd sockInt)

      -- | We'll ensure that the socket closes when its thread goes
      -- out of context even if an exception is thrown.
      k sock `finally` tryHardToClose sock

-- | Tries hard to close a 'Socket'. This operation *blocks* like any
-- 'Socket' @close@ operation, so it's possible it'll get interrupted
-- by the end user. "Trying hard" thus means that in the event of such
-- interruptions we retry closing the socket.
-- 
-- TODO: Should we just retry forever? Otherwise sockets might need to
-- store a "death-counter" which indicates how many times we've tried
-- to close them.
tryHardToClose :: Socket s p -> IO ()
tryHardToClose s = do
  res <- nn_close s
  case res of
    n | n == 0 -> return ()

    -- Socket closure failed.
    --
    -- The only possible reasons for failure are
    --
    -- EBADF "The provided socket is invalid." Should be impossible
    -- due to types.
    -- 
    -- EINTR "Operation was interrupted by a signal. The socket is not
    -- fully closed yet. Operation can be re-started by calling
    -- nn_close() again."
    --
    -- In the event we get EINTR we'll retry this closure.
      | otherwise -> do
      errno <- nnGetErrno
      case errno of
        e | e == eINTR -> tryHardToClose s
          | otherwise ->
            error "Network.Nanomsg.C.Core.withNew \"impossible\" error"

-- | A selection of errors that may occur at runtime during 'bind's
-- and 'connect's.
data EndpointError
  = NonexistentDevice
    -- ^ "Address specifies a nonexistent interface."
  | AddressInUse
    -- ^ "The requested local endpoint is already in use."
  | AddressTooLong
    -- ^ "The supplied address is too long."
  | UnavailableInterface
    -- ^"The requested endpoint is not local."
  | UnsupportedProtocol
    -- ^ "The requested transport protocol is not supported."
    deriving (Eq, Ord)

instance Show EndpointError where
  show NonexistentDevice    = "Address specifies a nonexistent interface."
  show AddressInUse         = "The requested local endpoint is already in use."
  show AddressTooLong       = "The supplied address is too long."
  show UnsupportedProtocol  = "The requested transport protocol is not supported."
  show UnavailableInterface = "The requested endpoint is not local."
  
    
-- | Binds a a 'Socket' to an 'Address' and get an 'Endpoint'
-- representing that binding.
bind :: Address tr Bind -> Socket s p -> IO (Either EndpointError (Endpoint s))
bind address socket =
  S.useAsCString (ser address) $ \cstr -> do
    res <- nn_bind socket cstr
    case res of

      -- Could not bind the address
      --
      -- This operation could fail for many reasons, ordered by how
      -- likely they are to be handled in the runtime.
      --
      -- ENODEV "Address specifies a nonexistent interface."
      -- Absolutely a handleable runtime error.
      --
      -- EADDRINUSE "The requested local endpoint is already in use."
      -- Absolutely a handleable runtime error.
      --
      -- ENAMETOOLONG "The supplied address is too long." Possible and
      -- only checkable at runtime (How early can we check it though?
      -- Can we have the ToString instance of 'Address' throw errors
      -- immediately?). We'll pass this back (for now).
      --
      -- TODO: Finish 'IsString' for 'Address'.
      --
      -- EADDRNOTAVAIL "The requested endpoint is not local."
      -- Restricted somewhat, but if the user tries to connect on an
      -- interface that doesn't exist then this will happen.
      --
      -- EPROTONOSUPPORT "The requested transport protocol is not
      -- supported." I'm uncertain why this error would occur. Can it
      -- be constrained by types?
      --
      -- TODO: Constrain EPROTONOSUPPORT with types.
      --
      -- EMFILE "Maximum number of active endpoints was reached." It's
      -- *possible* that this could be handled in process. Unsure what
      -- to do about it, really. Right now it'll be considered an
      -- IOError akin to running out of file handlers.
      --
      -- TODO: Describe reasons for and against exposing this error to
      -- the user.
      --
      -- ETERM "The library is terminating." Unsalvagable, we'll
      -- upgrade it to a Haskell 'IOException'.
      --
      -- EBADF "The provided socket is invalid." Impossible,
      -- constrained by types.
      -- 
      -- EINVAL "The syntax of the supplied address is invalid."
      -- Impossible, constrained by types once 'Address'es are
      -- in-place.
      --

      r | r < 0 ->
        case Errno r of
          e | e == eNODEV          -> return (Left NonexistentDevice)
            | e == eADDRINUSE      -> return (Left AddressInUse)
            | e == eNAMETOOLONG    -> return (Left AddressTooLong)
            | e == eADDRNOTAVAIL   -> return (Left UnavailableInterface)
            | e == ePROTONOSUPPORT -> return (Left UnsupportedProtocol)
            | e == eMFILE -> ioError $ IOError
              { ioe_handle      = Nothing
              , ioe_type        = ResourceExhausted
              , ioe_location    = "Network.Nanomsg.C.Core.bind"
              , ioe_description = show e
              , ioe_errno       = Just (errnoInt e)
              , ioe_filename    = Nothing
              }
            | e == eTERM -> ioError $ IOError
              { ioe_handle      = Nothing
              , ioe_type        = IllegalOperation
              , ioe_location    = "Network.Nanomsg.C.Core.bind"
              , ioe_description = show e
              , ioe_errno       = Just (errnoInt e)
              , ioe_filename    = Nothing
              }
            | otherwise ->
              error "Network.Nanomsg.C.Core.bind \"impossible\" error"

        | otherwise -> return $ Right $ Endpoint r (ser address)

-- CCalls
---------

foreign import ccall unsafe "nn.h nn_socket"
  nn_socket :: Domain -> CInt -> IO CInt

foreign import ccall unsafe "nn.h nn_close"
  nn_close :: Socket s p -> IO CInt

foreign import ccall unsafe "nn.h nn_bind"
  nn_bind :: Socket s p -> CString -> IO CInt

foreign import ccall unsafe "nn.h nn_connect"
  nn_connect :: Socket s p -> CString -> IO CInt

foreign import ccall unsafe "nn.h nn_shutdown"
  nn_shutdown :: Socket s p -> CInt {- ^ endpoint -} -> IO CInt
